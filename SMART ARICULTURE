#include <ESP8266WiFi.h> 
#include <DHT.h> 
#include <ThingSpeak.h> 
#include <Wire.h> 
#include <LiquidCrystal_I2C.h> 
// ========== CONFIGURATION - UPDATE THESE ========== 
const char* ssid = "YOUR_WIFI_NAME";           // Your WiFi name 
const char* password = "YOUR_WIFI_PASSWORD";   // Your WiFi password 
unsigned long channelID = 0000000;             // ThingSpeak Channel ID 
const char* writeAPIKey = "YOUR_WRITE_KEY";    // ThingSpeak Write API Key 
const char* readAPIKey = "YOUR_READ_KEY";      // ThingSpeak Read API Key 
// ================================================== 
// Pin Definitions 
#define DHTPIN D4          // DHT11 data pin (GPIO2) 
#define DHTTYPE DHT11      // DHT11 sensor type 
#define SOIL_ANALOG A0     // Soil moisture 1 (analog) 
#define SOIL_DIGITAL D6    // Soil moisture 2 (digital) 
#define LDR_PIN D5         // Light sensor (GPIO14) 
#define RELAY_PIN D1       // Relay control (GPIO5) 
#define LED_GREEN D2       // Status LED green 
#define LED_RED D0         // Status LED red 
// Thresholds (adjust based on your plants) 
#define SOIL_DRY 30        // Soil moisture % - water if below 
#define SOIL_WET 70        // Soil moisture % - stop if above 
#define LIGHT_THRESHOLD 40 // Light % - indicates day/night 
// Objects 
DHT dht(DHTPIN, DHTTYPE); 
WiFiClient client; 
LiquidCrystal_I2C lcd(0x27, 16, 2); // LCD address 0x27 or 0x3F 
 
// Variables 
float temperature = 0; 
float humidity = 0; 
int soilMoisture1 = 0;     // Percentage 
int soilMoisture2 = 0;     // Digital (wet/dry) 
int lightLevel = 0;        // Percentage 
bool pumpState = false; 
bool autoMode = true; 
 
// Timing 
unsigned long lastUpdate = 0; 
unsigned long lastWatering = 0; 
unsigned long pumpStartTime = 0; 
const long updateInterval = 20000;    // Upload every 20 seconds 
const long wateringInterval = 300000; // Minimum 5 min between watering 
const long maxPumpTime = 10000;       // Max 10 seconds per watering 
 
// LCD usage flag 
bool useLCD = false; // Set to true if LCD is connected 
 
void setup() { 
  Serial.begin(115200); 
  Serial.println("\n\n=== IoT Smart Farming System ==="); 
   
  // Initialize pins 
  pinMode(RELAY_PIN, OUTPUT); 
  pinMode(LED_GREEN, OUTPUT); 
  pinMode(LED_RED, OUTPUT); 
  pinMode(SOIL_DIGITAL, INPUT); 
   
  digitalWrite(RELAY_PIN, LOW);  // Pump OFF 
  digitalWrite(LED_GREEN, LOW); 
  digitalWrite(LED_RED, HIGH);   // Red = not connected 
   
  // Initialize DHT11 
  dht.begin(); 
   
  // Initialize LCD (if connected) 
  if (useLCD) { 
    lcd.init(); 
    lcd.backlight(); 
    lcd.setCursor(0, 0); 
    lcd.print("Smart Farm v1.0"); 
    lcd.setCursor(0, 1); 
    lcd.print("Starting..."); 
  } 
   
  // Connect to WiFi 
  connectWiFi(); 
   
  // Initialize ThingSpeak 
  ThingSpeak.begin(client); 
   
  Serial.println("System Ready!"); 
  if (useLCD) { 
    lcd.clear(); 
    lcd.print("System Ready!"); 
  } 
  delay(2000); 
} 
 
void loop() { 
  unsigned long currentMillis = millis(); 
   
  // Read all sensors 
  readSensors(); 
   
  // Automatic watering logic 
  if (autoMode) { 
    autoWatering(); 
  } 
   
  // Check for pump timeout 
  checkPumpTimeout(); 
   
  // Upload data to cloud 
  if (currentMillis - lastUpdate >= updateInterval) { 
    uploadToCloud(); 
    checkRemoteCommands(); 
    lastUpdate = currentMillis; 
  } 
   
  // Update display 
  updateDisplay(); 
   
  // Print status to Serial 
  printStatus(); 
   
  delay(2000); // Main loop delay 
} 
 
void connectWiFi() { 
  Serial.print("Connecting to WiFi: "); 
  Serial.println(ssid); 
   
  WiFi.begin(ssid, password); 
   
  int attempts = 0; 
  while (WiFi.status() != WL_CONNECTED && attempts < 30) { 
    delay(500); 
    Serial.print("."); 
    digitalWrite(LED_RED, !digitalRead(LED_RED)); // Blink red LED 
    attempts++; 
  } 
   
  if (WiFi.status() == WL_CONNECTED) { 
    Serial.println("\nWiFi Connected!"); 
    Serial.print("IP Address: "); 
    Serial.println(WiFi.localIP()); 
    digitalWrite(LED_RED, LOW); 
    digitalWrite(LED_GREEN, HIGH); 
     
    if (useLCD) { 
      lcd.clear(); 
      lcd.print("WiFi Connected!"); 
      lcd.setCursor(0, 1); 
      lcd.print(WiFi.localIP()); 
      delay(2000); 
    } 
  } else { 
    Serial.println("\nWiFi Connection Failed!"); 
    digitalWrite(LED_RED, HIGH); 
    digitalWrite(LED_GREEN, LOW); 
  } 
} 
 
void readSensors() { 
  // Read DHT11 
  temperature = dht.readTemperature(); 
  humidity = dht.readHumidity(); 
   
  // Validate DHT readings 
  if (isnan(temperature) || isnan(humidity)) { 
    Serial.println("DHT11 read failed!"); 
    temperature = 0; 
    humidity = 0; 
  } 
   
  // Read soil moisture (analog) - convert to percentage 
  // Calibration: Dry air = ~1023, Water = ~300-400 
  int soilRaw = analogRead(SOIL_ANALOG); 
  soilMoisture1 = map(soilRaw, 1023, 300, 0, 100); 
  soilMoisture1 = constrain(soilMoisture1, 0, 100); 
   
  // Read soil moisture (digital) - 0 = wet, 1 = dry 
  soilMoisture2 = digitalRead(SOIL_DIGITAL) == LOW ? 100 : 0; 
   
  // Read light level (LDR via voltage divider) 
  int lightRaw = analogRead(A0); // NodeMCU shares A0 
  // Quick read of LDR on D5 using analogRead after switching 
  pinMode(LDR_PIN, INPUT); 
  delay(10); 
  lightRaw = digitalRead(LDR_PIN) ? 100 : 0; // Simple digital read 
  lightLevel = lightRaw; 
   
  // Better LDR reading using actual analog (if available) 
  // For NodeMCU, LDR should be on A0 with voltage divider 
  // lightRaw ranges from 0 (dark) to 1023 (bright) 
  lightLevel = map(lightRaw, 0, 1023, 0, 100); 
  lightLevel = constrain(lightLevel, 0, 100); 
} 
 
void autoWatering() { 
  unsigned long currentMillis = millis(); 
   
  // Check if soil is dry and enough time has passed since last watering 
  if (soilMoisture1 < SOIL_DRY && !pumpState) { 
    if (currentMillis - lastWatering >= wateringInterval) { 
      // Start watering 
      digitalWrite(RELAY_PIN, HIGH); 
      pumpState = true; 
      pumpStartTime = currentMillis; 
      lastWatering = currentMillis; 
      Serial.println("AUTO: Watering started - Soil is dry"); 
       
      if (useLCD) { 
        lcd.clear(); 
        lcd.print("Watering..."); 
      } 
    } 
  } 
   
  // Stop watering if soil is wet 
  if (soilMoisture1 > SOIL_WET && pumpState) { 
    digitalWrite(RELAY_PIN, LOW); 
    pumpState = false; 
    Serial.println("AUTO: Watering stopped - Soil is wet"); 
  } 
} 
 
void checkPumpTimeout() { 
  // Safety: Turn off pump after max time 
  if (pumpState && (millis() - pumpStartTime >= maxPumpTime)) { 
    digitalWrite(RELAY_PIN, LOW); 
    pumpState = false; 
    Serial.println("SAFETY: Pump timeout - Stopped"); 
  } 
} 
 
void uploadToCloud() { 
  if (WiFi.status() != WL_CONNECTED) { 
    Serial.println("WiFi disconnected. Reconnecting..."); 
    connectWiFi(); 
    return; 
  } 
   
  // Set ThingSpeak fields 
  ThingSpeak.setField(1, temperature); 
  ThingSpeak.setField(2, humidity); 
  ThingSpeak.setField(3, soilMoisture1); 
  ThingSpeak.setField(4, lightLevel); 
  ThingSpeak.setField(5, pumpState ? 1 : 0); 
  ThingSpeak.setField(6, autoMode ? 1 : 0); 
  ThingSpeak.setField(7, soilMoisture2); 
   
  // Upload 
  int response = ThingSpeak.writeFields(channelID, writeAPIKey); 
   
  if (response == 200) { 
    Serial.println("✓ Data uploaded to cloud"); 
    digitalWrite(LED_GREEN, HIGH); 
  } else { 
    Serial.println("✗ Upload failed: " + String(response)); 
    digitalWrite(LED_GREEN, LOW); 
  } 
} 
 
void checkRemoteCommands() { 
  // Read command field from ThingSpeak (Field 8) 
  int command = ThingSpeak.readIntField(channelID, 8, readAPIKey); 
   
  if (command == 200) { // Success 
    int value = ThingSpeak.getLastReadStatus(); 
     
    if (value == 1) { 
      // Command: Turn pump ON manually 
      digitalWrite(RELAY_PIN, HIGH); 
      pumpState = true; 
      autoMode = false; 
      pumpStartTime = millis(); 
      Serial.println("REMOTE: Manual pump ON"); 
    }  
    else if (value == 2) { 
      // Command: Turn pump OFF manually 
      digitalWrite(RELAY_PIN, LOW); 
      pumpState = false; 
      autoMode = false; 
      Serial.println("REMOTE: Manual pump OFF"); 
    }  
    else if (value == 3) { 
      // Command: Enable AUTO mode 
      autoMode = true; 
      Serial.println("REMOTE: Auto mode enabled"); 
    } 
  } 
} 
 
void updateDisplay() { 
  if (!useLCD) return; 
   
  static unsigned long lastLCDUpdate = 0; 
  static int displayMode = 0; 
   
  if (millis() - lastLCDUpdate > 3000) { // Update every 3 seconds 
    lcd.clear(); 
     
    switch(displayMode) { 
      case 0: // Temperature & Humidity 
        lcd.setCursor(0, 0); 
        lcd.print("Temp: "); 
        lcd.print(temperature, 1); 
        lcd.print(" C"); 
         
        lcd.setCursor(0, 1); 
        lcd.print("Humidity: "); 
        lcd.print(humidity, 0); 
        lcd.print("%"); 
        break; 
         
      case 1: // Soil & Light 
        lcd.setCursor(0, 0); 
        lcd.print("Soil: "); 
        lcd.print(soilMoisture1); 
        lcd.print("%"); 
         
        lcd.setCursor(0, 1); 
        lcd.print("Light: "); 
        lcd.print(lightLevel); 
        lcd.print("%"); 
        break; 
         
      case 2: // Status 
        lcd.setCursor(0, 0); 
        lcd.print("Pump: "); 
        lcd.print(pumpState ? "ON " : "OFF"); 
         
        lcd.setCursor(0, 1); 
        lcd.print("Mode: "); 
        lcd.print(autoMode ? "AUTO" : "MANUAL"); 
        break; 
    } 
     
    displayMode = (displayMode + 1) % 3; 
    lastLCDUpdate = millis(); 
  } 
} 
 
void printStatus() { 
  static unsigned long lastPrint = 0; 
   
  if (millis() - lastPrint > 5000) { // Print every 5 seconds 
    Serial.println("\n========== STATUS =========="); 
    Serial.print("Temperature: "); Serial.print(temperature); 
Serial.println(" °C"); 
    Serial.print("Humidity: "); Serial.print(humidity); Serial.println(" %"); 
    Serial.print("Soil Moisture 1: "); Serial.print(soilMoisture1); 
Serial.println(" %"); 
    Serial.print("Soil Moisture 2: "); Serial.println(soilMoisture2 > 50 ? 
"WET" : "DRY"); 
    Serial.print("Light Level: "); Serial.print(lightLevel); Serial.println(" 
%"); 
    Serial.print("Pump: "); Serial.println(pumpState ? "ON" : "OFF"); 
    Serial.print("Mode: "); Serial.println(autoMode ? "AUTO" : "MANUAL"); 
    Serial.print("WiFi: "); Serial.println(WiFi.status() == WL_CONNECTED ? 
"Connected" : "Disconnected"); 
    Serial.println("============================\n"); 
     
    lastPrint = millis(); 
  } 
}
